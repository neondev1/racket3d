;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-beginner-abbr-reader.ss" "lang")((modname bst) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #f #t none #f () #t)))
(require spd/tags)

(require "provide.rkt")
(provide (matching-identifiers-out #rx"^((?!--).)*$" (all-defined-out)))

(require "common.rkt")
(@htdd Colour Vector Euler Triangle)

;;
;; BST.rkt
;;
;; Binary search tree data definitions and utility functions
;; since BSL doesn't have a collection with faster than O(n) lookup
;;


;;
;; DATA DEFINITIONS
;;


(@htdd BST)
(define-struct node (key value left right))
;; BST is one of:
;;  - false
;;  - (make-node Natural X BST BST)
;; interp. a node in a binary search tree, with its key/value and children
;;         (generics don't exist in SPD but I don't really care)
;; CONSTRAINT: all keys in left must be less than key;
;;             all keys in right must be greater than key;
;;             all keys must be unique
(define EMPTY-BST false)
(define BST1 (make-node 6 6 false false))
(define BST2 (make-node 5 5 (make-node 4 4 false false) false))
(define BST3 (make-node 3 3
                        (make-node 1 1
                                   (make-node 0 0 false false)
                                   (make-node 2 2 false false))
                        false)) ;example of a BST with optimal depth;
;                               ;could be generated by construct-bst
(define BST4 (make-node 2 2
                        (make-node 0 0
                                   false
                                   (make-node 1 1 false false))
                        (make-node 3 3 false false))) ;example of an optimal BST
;                                                     ;that cannot be generated
(define BST5 (make-node 3 3
                        (make-node 2 2
                                   (make-node 0 0
                                              false
                                              (make-node 1 1 false false))
                                   false)
                        false)) ;suboptimal depth BST example

(@dd-template-rules one-of          ;2 cases
                    atomic-distinct ;false
                    compound        ;(make-node Natural X BST BST)
                    self-ref        ;(node-left BST) is BST
                    self-ref)       ;(node-right BST) is BST

(define (fn-for-bst bst)
  (cond [(false? bst)
         (...)]
        [else
         (... (node-key bst)
              (node-value bst)
              (fn-for-bst (node-left bst))
              (fn-for-bst (node-right bst)))]))


;;
;; FUNCTIONS
;;


(@htdf lookup)
(@signature BST Natural -> X or false)
;; produce value of node in tree with given key, or false if it does not exist
(check-expect (lookup BST3 2) 2)
(check-expect (lookup BST5 1) 1)
(check-expect (lookup BST4 0) 0)
(check-expect (lookup BST4 4) false)

(@template-origin BST)

(define (lookup tree key)
  (cond [(false? tree)
         false]
        [else
         (cond [(= key (node-key tree))
                (node-value tree)]
               [(< key (node-key tree))
                (lookup (node-left tree) key)]
               [else
                (lookup (node-right tree) key)])]))


#|
(Probably) O(n) BST construction from a singly linked list
Some notes:
- Generating the pattern for the BST takes O(n) time (due to using reverse).
- The actual traversal performs one pass over the list, mostly calling
  non-recursive (O(1)) functions on each element for total complexity O(n).
- The only recursive functions called are drop and fold. However, the total
  number of calls (recursive or non-recursive) to each function is guaranteed
  to be less than the number of elements in the list.
- Hence the overall time complexity should probably be O(n), which is optimal.
- I have no idea if this algorithm is optimal or overcomplicated; I came up
  with its design while sleep deprived at like 2 AM and never touched it again.
|#


(@htdf construct-bst construct-bst--acc)
(@signature (listof X) Natural -> BST)
;; construct binary search tree from given list of known length
(check-expect (construct-bst empty 0) EMPTY-BST)
;; As the behaviour of this implementation for large lists is difficult to infer
;; and manually creating such test cases is impractical, this function is tested
;; against a naive genrec implementation which is defined later in this file.
(check-expect (construct-bst (make-list--test 10000) 10000)
              (construct-bst-naive--test (make-list--test 10000) 10000))
(check-expect (construct-bst (make-list--test 12345) 12345)
              (construct-bst-naive--test (make-list--test 12345) 12345))
(check-expect (construct-bst (make-list--test 15360) 15360)
              (construct-bst-naive--test (make-list--test 15360) 15360))
(check-expect (construct-bst (make-list--test 15361) 15361)
              (construct-bst-naive--test (make-list--test 15361) 15361))
(check-expect (construct-bst (make-list--test 16383) 16383)
              (construct-bst-naive--test (make-list--test 16383) 16383))
(check-expect (construct-bst (make-list--test 16384) 16384)
              (construct-bst-naive--test (make-list--test 16384) 16384))
(check-expect (construct-bst (make-list--test 16404) 16404)
              (construct-bst-naive--test (make-list--test 16404) 16404))

(@template-origin accumulator)

(define (construct-bst lst count)
  (cond [(empty? lst)
         EMPTY-BST]
        [else
         (construct-bst--acc (rest lst)
                             (rest (bst-pattern count)) 0
                             empty 1 empty
                             (make-node 0 (first lst) false false)
                             empty)]))

(@template-origin (listof X) accumulator)

;; depths is (listof Natural)
;; INVARIANT: the depth of every node to be created from the corresponding
;;            element in lst; 0 is deepest and greater values are less deep
;;
;; last-depth is Natural
;; INVARIANT: the depth of the last element of lst seen
;;
;; working-depths is (listof Natural)
;; INVARIANT: the maximum node depth of every BST in imperfect
;;
;; index is Natural
;; INVARIANT: the zero-based index of the current element of lst
;;
;; fold-counts is (listof Natural)
;; INVARIANT: the sequence of numbers of fold operations required to construct
;;            a complete binary search tree from perfect and trees in imperfect
;;
;; perfect is BST
;; INVARIANT: the last perfect binary search tree constructed that has not
;;            been added to a larger tree; false if it does not exist
;;
;; imperfect is (listof BST)
;; INVARIANT: the list of all imperfect binary search trees constructed,
;;            in reverse chronological order
(define (construct-bst--acc lst depths last-depth working-depths
                            index fold-counts perfect imperfect)
  (cond [(empty? lst)
         (if (empty? imperfect)
             perfect
             (fold perfect imperfect
                   (first (reverse fold-counts))))]
        [else
         (cond [(zero? (first depths))
                (if (= last-depth 1)
                    (construct-bst--acc (rest lst) (rest depths) 0
                                        (drop working-depths
                                              (first fold-counts))
                                        (add1 index) (rest fold-counts)
                                        (fold (make-node index (first lst)
                                                         false false)
                                              imperfect (first fold-counts))
                                        (drop imperfect (first fold-counts)))
                    (construct-bst--acc (rest lst) (rest depths) 0
                                        working-depths
                                        (add1 index) fold-counts
                                        (make-node index (first lst)
                                                   false false)
                                        imperfect))]
               [(or (empty? imperfect)
                    (not (= (first depths) (sub1 (first working-depths)))))
                (construct-bst--acc (rest lst) (rest depths) (first depths)
                                    (cons (first depths) working-depths)
                                    (add1 index) (cons (first depths)
                                                       fold-counts)
                                    false
                                    (cons (make-node index (first lst)
                                                     perfect false)
                                          imperfect))]
               [else
                (construct-bst--acc (rest lst) (rest depths) (first depths)
                                    (cons (first depths) working-depths)
                                    (add1 index) fold-counts
                                    false
                                    (cons (make-node index (first lst)
                                                     perfect false)
                                          imperfect))])]))
;; This function rather grossly violates style rules (being much longer than the
;; stipulated ~10-line limit), though it is unlikely that shortening it is
;; possible without breaking more design rules due to its relatively complex
;; logic and tail-recursive nature, which is necessary for efficiency reasons.



(@htdf fold)
(@signature BST (listof BST) Natural -> BST)
;; recursively attach perfect to (first imperfect) until empty, or count is 0
(check-expect (fold BST1 empty 0) BST1)
(check-expect (fold BST1 empty 3) BST1)
(check-expect (fold (make-node 4 4 false false) (list BST3) 0)
              (make-node 4 4 false false))
(check-expect (fold (make-node 4 4 false false) (list BST3) 1)
              (make-node 3 3
                         (make-node 1 1
                                    (make-node 0 0 false false)
                                    (make-node 2 2 false false))
                         (make-node 4 4 false false)))
(check-expect (fold (make-node 4 4 false false) (list BST3) 2)
              (make-node 3 3
                         (make-node 1 1
                                    (make-node 0 0 false false)
                                    (make-node 2 2 false false))
                         (make-node 4 4 false false)))
(check-expect (fold BST1 (list BST2 BST3) 2)
              (make-node 3 3
                         (make-node 1 1
                                    (make-node 0 0 false false)
                                    (make-node 2 2 false false))
                         (make-node 5 5
                                    (make-node 4 4 false false)
                                    (make-node 6 6 false false))))
(check-expect (fold (make-node 10 10 false false)
                    (list (make-node 9 9 (make-node 8 8 false false) false)
                          (make-node 7 7 (fold BST1 (list BST2 BST3) 2) false))
                    1)
              (make-node 9 9
                         (make-node 8 8 false false)
                         (make-node 10 10 false false)))
(check-expect (fold (make-node 10 10 false false)
                    (list (make-node 9 9 (make-node 8 8 false false) false)
                          (make-node 7 7 (fold BST1 (list BST2 BST3) 2) false))
                    3)
              (make-node 7 7
                         (fold BST1 (list BST2 BST3) 2)
                         (make-node 9 9
                                    (make-node 8 8 false false)
                                    (make-node 10 10 false false))))

(@template-origin 2-one-of accumulator)

#|
             count    0              (add1 Natural)
imperfect

empty                 perfect [0]    perfect [0]

(cons BST             perfect [0]    (fold (set-right (first imperfect) perfect)
      (listof BST))                        (rest imperfect) (sub1 count)) [1]
|#

;; perfect is BST
;; INVARIANT: the last perfect binary search tree constructed
(define (fold perfect imperfect count)
  (cond [(or (zero? count) (empty? imperfect)) ;[0]
         perfect]
        [else                                  ;[1]
         (fold (set-right (first imperfect) perfect)
               (rest imperfect) (sub1 count))]))



(@htdf set-right)
(@signature BST BST -> BST)
;; produce first BST with right child set to second BST
;; CONSTRAINT: first BST must be nonempty
(check-expect (set-right BST3 false) BST3)
(check-expect (set-right BST3 (make-node 5 5
                                         (make-node 4 4 false false)
                                         (make-node 6 6 false false)))
              (make-node 3 3
                         (make-node 1 1
                                    (make-node 0 0 false false)
                                    (make-node 2 2 false false))
                         (make-node 5 5
                                    (make-node 4 4 false false)
                                    (make-node 6 6 false false))))
(check-expect (set-right BST4 false)
              (make-node 2 2
                         (make-node 0 0
                                    false
                                    (make-node 1 1 false false))
                         false))

(@template-origin BST)

(define (set-right bst right)
  (cond [(false? bst)
         (error "First BST must be nonempty")]
        [else
         (make-node (node-key bst)
                    (node-value bst)
                    (node-left bst)
                    right)]))



(@htdf bst-pattern)
(@signature Natural -> (listof Natural))
;; produce list of BST node depths for a list with count elements; 0 is deepest
;; CONSTRAINT: count must be nonzero
(check-expect (bst-pattern 1)  (list 0))
(check-expect (bst-pattern 3)  (list 0 1 0))
(check-expect (bst-pattern 10) (list 0 1 0 2 0 1 0 3 0 1))
(check-expect (bst-pattern 15) (list 0 1 0 2 0 1 0 3 0 1 0 2 0 1 0))
;; This really just generates the zero-based ruler sequence (OEIS: A007814)

(@template-origin fn-composition)

(define (bst-pattern count)
  (depth->bst-pattern (floor (log2 count)) count))



(@htdf depth->bst-pattern depth->bst-pattern--acc)
(@signature Natural -> (listof Natural))
;; produce list of BST node depths for a BST with given depth, trimmed to count
(check-expect (depth->bst-pattern 1 1)  (list 0))
(check-expect (depth->bst-pattern 2 3)  (list 0 1 0))
(check-expect (depth->bst-pattern 4 10) (list 0 1 0 2 0 1 0 3 0 1))
(check-expect (depth->bst-pattern 4 15) (list 0 1 0 2 0 1 0 3 0 1 0 2 0 1 0))

(@template-origin accumulator)

(define (depth->bst-pattern depth count)
  (reverse (drop (depth->bst-pattern--acc depth 0 empty)
                 (- (sub1 (expt 2 (add1 depth))) count))))

(@template-origin genrec accumulator)

;; depth is Natural
;; INVARIANT: depth of the current part of the BST pattern being generated
;;
;; last is (listof Natural)
;; INVARIANT: previously generated part of the pattern, up to and not including
;;            the current depth; represents deeper parts of the BST
;;
;; Genrec info
;; Trivial case:   (= depth target)
;; Reduction step: (add1 depth)
;; Termination argument:
;;   For natural number target >= 0 and depth starting at 0,
;;   adding 1 to depth will cause it to eventually reach target
(define (depth->bst-pattern--acc target depth last)
  (if (= depth target)
      (cons-pattern depth last)
      (depth->bst-pattern--acc target (add1 depth) (cons-pattern depth last))))



(@htdf cons-pattern)
(@signature Natural (listof Natural) -> (listof Natural))
;; produce next pattern by prepending and appending list to given number
(check-expect (cons-pattern 0 empty) (list 0))
(check-expect (cons-pattern 4 (list 1 2 3)) (list 1 2 3 4 1 2 3))
(check-expect (cons-pattern 3 (list 0 1 0 2 0 1 0))
              (list 0 1 0 2 0 1 0 3 0 1 0 2 0 1 0))

(@template-origin Natural)

(define (cons-pattern n lon)
  (append lon (list n) lon))



(@htdf log2)
(@signature Number -> Number)
;; produce log base 2 of a number
;; CONSTRAINT: the given number must be positive
(check-expect (log2 0.5) -1)
(check-expect (log2 1) 0)
(check-expect (log2 16) 4)
(check-expect (log2 4294967296) 32)
(check-within (log2 10000) 13.28771237954945 DELTA)

(@template-origin Number)

(define (log2 x)
  (inexact->exact (/ (log x) (log 2))))


;;
;; TESTING FUNCTIONS
;;
;; Function names in this section are generally suffixed with --test
;; to prevent them from being exported (by matching-identifiers-out)
;;


(@htdf construct-bst-naive--test construct-bst-naive--acc)
(@signature (listof X) Natural -> BST)
;; construct binary search tree from given list (slow/non-TR implementation)
(check-expect (construct-bst-naive--test empty 0) EMPTY-BST)
(check-expect (construct-bst-naive--test (list 0) 1)
              (make-node 0 0 false false))
(check-expect (construct-bst-naive--test (list 0 1 2 3 4) 5)
              (make-node 3 3
                         (make-node 1 1
                                    (make-node 0 0 false false)
                                    (make-node 2 2 false false))
                         (make-node 4 4 false false)))
(check-expect (construct-bst-naive--test (list 0 1 2 3 4 5 6) 7)
              (make-node 3 3
                         (make-node 1 1
                                    (make-node 0 0 false false)
                                    (make-node 2 2 false false))
                         (make-node 5 5
                                    (make-node 4 4 false false)
                                    (make-node 6 6 false false))))

(@template-origin accumulator)

(define (construct-bst-naive--test lst count)
  (construct-bst-naive--acc lst 0))

(@template-origin genrec accumulator)

;; key is Natural
;; INVARIANT: the key of the first element of lst
;;
;; Genrec info
;; Trivial case:   (empty? lst)
;; Reduction step: (take lst (sub1 (expt 2 (floor (log2 (length lst)))))),
;;                 (drop lst (expt 2 (floor (log2 (length lst)))))
;; Termination argument:
;;   (sub1 (expt 2 (floor (log2 (length lst))))) < (length lst) and
;;   (expt 2 (floor (log2 (length lst)))) > 0;
;;   thus the lists generated by the reduction step are necessarily proper
;;   subsets of the original list, and repeatedly taking proper subsets of
;;   a finite list will eventually result in an empty list (trivial case).
(define (construct-bst-naive--acc lst key)
  (if (empty? lst)
      EMPTY-BST
      (make-node (+ key (sub1 (expt 2 (floor (log2 (length lst))))))
                 (list-ref lst (sub1 (expt 2 (floor (log2 (length lst))))))
                 (construct-bst-naive--acc
                  (take lst (sub1 (expt 2 (floor (log2 (length lst))))))
                  key)
                 (construct-bst-naive--acc
                  (drop lst (expt 2 (floor (log2 (length lst)))))
                  (+ key (expt 2 (floor (log2 (length lst)))))))))



(@htdf make-list--test)
(@signature Natural -> (listof Natural))
;; produce ascending list of nonnegative integers up to but not including n
(check-expect (make-list--test 0)  (list))
(check-expect (make-list--test 1)  (list 0))
(check-expect (make-list--test 10) (list 0 1 2 3 4 5 6 7 8 9))
(check-expect (make-list--test 16) (list 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15))

(@template-origin accumulator)

(define (make-list--test n)
  (make-list--acc n empty))

(@template-origin Natural accumulator)

;; rsf is (listof Natural)
;; INVARIANT: all numbers between the current number and n, excluding n
(define (make-list--acc n rsf)
  (cond [(zero? n)
         rsf]
        [else
         (make-list--acc (sub1 n) (cons (sub1 n) rsf))]))



(@htdf bst-time-regular--test)
(@signature Natural -> Natural)
;; produce time to construct a BST with n elements
;; (tests not possible)

(@template-origin Natural)

(define (bst-time-regular--test n)
  (- (- (first (list (current-milliseconds)
                     (construct-bst (make-list--test n) n)))
        (current-milliseconds))))



(@htdf bst-time-naive--test)
(@signature Natural -> Natural)
;; produce time to construct a BST with n elements using naive implementation
;; (tests not possible)

(@template-origin Natural)

(define (bst-time-naive--test n)
  (- (- (first (list (current-milliseconds)
                     (construct-bst-naive--test (make-list--test n) n)))
        (current-milliseconds))))

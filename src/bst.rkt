;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-beginner-reader.ss" "lang")((modname bst) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #f #t none #f () #t)))
(require spd/tags)

(require "provide.rkt")
(provide (except-out (matching-identifiers-out #rx"^((?!--).)*$"
                                               (all-defined-out))
                     construct-bst-naive
                     test-list
                     test-bst-time-regular
                     test-bst-time-naive))

(require "common.rkt")
(@htdd Colour Point Euler Triangle)

(require "vector.rkt")
(@htdd Vector Plane Line)

;;
;; BST.rkt
;;
;; Binary search tree data definitions and utility functions
;; since BSL doesn't have a collection with faster than O(n) lookup
;;


;;
;; DATA DEFINITIONS
;;


(@htdd BST)
(define-struct node (key value left right))
;; BST is one of:
;;  - false
;;  - (make-node Natural X BST BST)
;; interp. a node in a binary search tree, with its key/value and children
;;         (generics don't exist in SPD but I don't really care)
;; CONSTRAINT: all keys in left must be less than key;
;;             all keys in right must be greater than key;
;;             all keys must be unique
(define EMPTY-BST false)
(define BST1 (make-node 6 6 false false))
(define BST2 (make-node 5 5 (make-node 4 4 false false) false))
(define BST3 (make-node 3 3
                        (make-node 1 1
                                   (make-node 0 0 false false)
                                   (make-node 2 2 false false))
                        false)) ;example of a BST with optimal depth;
;                               ;could be generated by construct-bst
(define BST4 (make-node 2 2
                        (make-node 0 0
                                   false
                                   (make-node 1 1 false false))
                        (make-node 3 3 false false))) ;example of an optimal BST
;                                                     ;that cannot be generated
(define BST5 (make-node 3 3
                        (make-node 2 2
                                   (make-node 0 0
                                              false
                                              (make-node 1 1 false false))
                                   false)
                        false)) ;suboptimal depth BST example

(@dd-template-rules one-of          ;2 cases
                    atomic-distinct ;false
                    compound        ;(make-node Natural X BST BST)
                    self-ref        ;(node-left BST) is BST
                    self-ref)       ;(node-right BST) is BST

(define (fn-for-bst bst)
  (cond [(false? bst)
         (...)]
        [else
         (... (node-key bst)
              (node-value bst)
              (fn-for-bst (node-left bst))
              (fn-for-bst (node-right bst)))]))


;;
;; FUNCTIONS
;;


(@htdf lookup)
(@signature BST Natural -> X or false)
;; produce value of node in tree with given key, or false if it does not exist
(check-expect (lookup BST3 2) 2)
(check-expect (lookup BST5 1) 1)
(check-expect (lookup BST4 0) 0)
(check-expect (lookup BST4 4) false)

(@template-origin BST)

(@template
 (define (lookup tree key)
   (cond [(false? tree)
          (... key)]
         [else
          (... key
               (node-key tree)
               (node-value tree)
               (lookup (node-left tree) key)
               (lookup (node-right tree) key))])))

(define (lookup tree key)
  (cond [(false? tree)
         false]
        [else
         (cond [(= key (node-key tree))
                (node-value tree)]
               [(< key (node-key tree))
                (lookup (node-left tree) key)]
               [else
                (lookup (node-right tree) key)])]))



(@htdf construct-bst construct-bst--acc)
(@signature (listof X) Natural -> BST)
;; construct binary search tree from given list of known length
(check-expect (construct-bst empty 0) EMPTY-BST)
(check-expect (construct-bst (test-list 10000) 10000)
              (construct-bst-naive (test-list 10000) 10000))
(check-expect (construct-bst (test-list 12345) 12345)
              (construct-bst-naive (test-list 12345) 12345))
(check-expect (construct-bst (test-list 15361) 15361)
              (construct-bst-naive (test-list 15361) 15361))
(check-expect (construct-bst (test-list 16383) 16383)
              (construct-bst-naive (test-list 16383) 16383))
(check-expect (construct-bst (test-list 16384) 16384)
              (construct-bst-naive (test-list 16384) 16384))
(check-expect (construct-bst (test-list 16404) 16404)
              (construct-bst-naive (test-list 16404) 16404))

;(define (construct-bst lst count) EMPTY-BST) ;stub

(@template-origin accumulator)

(@template
 (define (construct-bst lst count)
   (... (construct-bst--acc (... lst) (... lst count)
                            (... lst count) (... lst count)
                            (... lst count) (... lst count)
                            (... lst count) (... lst count)))))

(define (construct-bst lst count)
  (cond [(empty? lst)
         EMPTY-BST]
        [else
         (construct-bst--acc (rest lst)
                             (rest (bst-pattern count)) 0
                             empty 1 empty
                             (make-node 0 (first lst) false false)
                             empty)]))

(@template-origin (listof X) accumulator)

(@template
 (define (construct-bst--acc lst depths last-depth working-depths
                             index fold-counts perfect imperfect)
   (cond [(empty? lst)
          (... depths last-depth working-depths
               index fold-counts perfect imperfect)]
         [else
          (... (first lst)
               depths last-depth working-depths
               index fold-counts perfect imperfect
               (construct-bst--acc (rest lst) (... depths)
                                   (... last-depth) (... eff-depth)
                                   (... index) (... fold-counts)
                                   (... perfect) (... imperfect)))])))

;; depths is (listof Natural)
;; INVARIANT: the depth of every node to be created from the corresponding
;;            element in lst; 0 is deepest and greater values are less deep
;;
;; last-depth is Natural
;; INVARIANT: the depth of the last element of lst seen
;;
;; working-depths is (listof Natural)
;; INVARIANT: the maximum node depth of every BST in imperfect
;;
;; index is Natural
;; INVARIANT: the zero-based index of the current element of lst
;;
;; fold-counts is (listof Natural)
;; INVARIANT: the sequence of numbers of fold operations required to construct
;;            a complete binary search tree from perfect and trees in imperfect
;;
;; perfect is BST
;; INVARIANT: the last perfect binary search tree constructed that has not
;;            been added to a larger tree; false if it does not exist
;;
;; imperfect is (listof BST)
;; INVARIANT: the list of all imperfect binary search trees constructed,
;;            in reverse chronological order
(define (construct-bst--acc lst depths last-depth working-depths
                            index fold-counts perfect imperfect)
  (cond [(empty? lst)
         (if (empty? imperfect)
             perfect
             (fold perfect imperfect
                   (first (reverse fold-counts))))]
        [else
         (cond [(zero? (first depths))
                (if (= last-depth 1)
                    (construct-bst--acc (rest lst) (rest depths) 0
                                        (drop working-depths
                                              (first fold-counts))
                                        (add1 index) (rest fold-counts)
                                        (fold (make-node index (first lst)
                                                         false false)
                                              imperfect (first fold-counts))
                                        (drop imperfect (first fold-counts)))
                    (construct-bst--acc (rest lst) (rest depths) 0
                                        working-depths
                                        (add1 index) fold-counts
                                        (make-node index (first lst)
                                                   false false)
                                        imperfect))]
               [(or (empty? imperfect)
                    (not (= (first depths) (sub1 (first working-depths)))))
                (construct-bst--acc (rest lst) (rest depths) (first depths)
                                    (cons (first depths) working-depths)
                                    (add1 index) (cons (first depths)
                                                       fold-counts)
                                    false
                                    (cons (make-node index (first lst)
                                                     perfect false)
                                          imperfect))]
               [else
                (construct-bst--acc (rest lst) (rest depths) (first depths)
                                    (cons (first depths) working-depths)
                                    (add1 index) fold-counts
                                    false
                                    (cons (make-node index (first lst)
                                                     perfect false)
                                          imperfect))])]))



(@htdf fold)
(@signature BST (listof BST) Natural -> BST)
;; recursively attach perfect to (first imperfect) until empty, or count is 0
(check-expect (fold BST1 empty 0) BST1)
(check-expect (fold BST1 empty 3) BST1)
(check-expect (fold (make-node 4 4 false false) (list BST3) 0)
              (make-node 4 4 false false))
(check-expect (fold (make-node 4 4 false false) (list BST3) 1)
              (make-node 3 3
                         (make-node 1 1
                                    (make-node 0 0 false false)
                                    (make-node 2 2 false false))
                         (make-node 4 4 false false)))
(check-expect (fold (make-node 4 4 false false) (list BST3) 2)
              (make-node 3 3
                         (make-node 1 1
                                    (make-node 0 0 false false)
                                    (make-node 2 2 false false))
                         (make-node 4 4 false false)))
(check-expect (fold BST1 (list BST2 BST3) 2)
              (make-node 3 3
                         (make-node 1 1
                                    (make-node 0 0 false false)
                                    (make-node 2 2 false false))
                         (make-node 5 5
                                    (make-node 4 4 false false)
                                    (make-node 6 6 false false))))
(check-expect (fold (make-node 10 10 false false)
                    (list (make-node 9 9 (make-node 8 8 false false) false)
                          (make-node 7 7 (fold BST1 (list BST2 BST3) 2) false))
                    1)
              (make-node 9 9
                         (make-node 8 8 false false)
                         (make-node 10 10 false false)))
(check-expect (fold (make-node 10 10 false false)
                    (list (make-node 9 9 (make-node 8 8 false false) false)
                          (make-node 7 7 (fold BST1 (list BST2 BST3) 2) false))
                    3)
              (make-node 7 7
                         (fold BST1 (list BST2 BST3) 2)
                         (make-node 9 9
                                    (make-node 8 8 false false)
                                    (make-node 10 10 false false))))

;(define (fold perfect imperfect depths) empty) ;stub

(@template-origin 2-one-of accumulator)

(@template
 (define (fold perfect imperfect count)
   (cond [(and (zero? count) (empty? imperfect))
          (... perfect)]
         [(zero? count)
          (... perfect)]
         [(empty? imperfect)
          (... perfect)]
         [else
          (... perfect (first imperfect) count
               (fold--acc (... perfect)
                          (rest imperfect) (sub1 count)))])))

#|
             count    0              (add1 Natural)
imperfect

empty                 perfect [0]    perfect [0]

(cons BST             perfect [0]    (fold (set-right (first imperfect) perfect)
      (listof BST))                        (rest imperfect) (sub1 count)) [1]
|#

;; perfect is BST
;; INVARIANT: the last perfect binary search tree constructed
(define (fold perfect imperfect count)
  (cond [(or (zero? count) (empty? imperfect)) ;[0]
         perfect]
        [else                                  ;[1]
         (fold (set-right (first imperfect) perfect)
               (rest imperfect) (sub1 count))]))



(@htdf set-right)
(@signature BST BST -> BST)
;; produce first BST with right child set to second BST
;; CONSTRAINT: first BST must be nonempty
(check-expect (set-right BST3 false) BST3)
(check-expect (set-right BST3 (make-node 5 5
                                         (make-node 4 4 false false)
                                         (make-node 6 6 false false)))
              (make-node 3 3
                         (make-node 1 1
                                    (make-node 0 0 false false)
                                    (make-node 2 2 false false))
                         (make-node 5 5
                                    (make-node 4 4 false false)
                                    (make-node 6 6 false false))))
(check-expect (set-right BST4 false)
              (make-node 2 2
                         (make-node 0 0
                                    false
                                    (make-node 1 1 false false))
                         false))

;(define (set-right bst right) EMPTY-BST) ;stub

(@template-origin BST)

(@template
 (define (set-right bst right)
   (cond [(false? bst)
          (...)]
         [else
          (... (node-key bst)
               (node-value bst)
               (fn-for-bst (node-left bst))
               (fn-for-bst (node-right bst))
               right)])))

(define (set-right bst right)
  (cond [(false? bst)
         (error "First BST must be nonempty")]
        [else
         (make-node (node-key bst)
                    (node-value bst)
                    (node-left bst)
                    right)]))



(@htdf bst-pattern)
(@signature Natural -> (listof Natural))
;; produce list of BST node depths for a list with count elements; 0 is deepest
;; CONSTRAINT: count must be nonzero
(check-expect (bst-pattern 1)  (list 0))
(check-expect (bst-pattern 3)  (list 0 1 0))
(check-expect (bst-pattern 10) (list 0 1 0 2 0 1 0 3 0 1))
(check-expect (bst-pattern 15) (list 0 1 0 2 0 1 0 3 0 1 0 2 0 1 0))
;; This really just generates the zero-based ruler sequence (OEIS: A007814)

;(define (bst-pattern count) empty) ;stub

(@template-origin fn-composition)

(define (bst-pattern count)
  (depth->bst-pattern (floor (log2 count)) count))



(@htdf depth->bst-pattern depth->bst-pattern--acc)
(@signature Natural -> (listof Natural))
;; produce list of BST node depths for a BST with given depth, trimmed to count
(check-expect (depth->bst-pattern 1 1)  (list 0))
(check-expect (depth->bst-pattern 2 3)  (list 0 1 0))
(check-expect (depth->bst-pattern 4 10) (list 0 1 0 2 0 1 0 3 0 1))
(check-expect (depth->bst-pattern 4 15) (list 0 1 0 2 0 1 0 3 0 1 0 2 0 1 0))

;(define (depth->bst-pattern depth count) empty) ;stub

(@template-origin accumulator)

(@template
 (define (depth->bst-pattern depth count)
   (... (depth->bst-pattern--acc (... depth count)
                                 (... depth count)
                                 (... depth count)))))

(define (depth->bst-pattern depth count)
  (reverse (drop (depth->bst-pattern--acc depth 0 empty)
                 (- (sub1 (expt 2 (add1 depth))) count))))

(@template-origin genrec accumulator)

(@template
 (define (depth->bst-pattern--acc target depth last)
   (if (... target depth last)
       (... target depth last)
       (... target depth last
            (depth->bst-pattern--acc target (... depth) (... last))))))

;; depth is Natural
;; INVARIANT: depth of the current part of the BST pattern being generated
;;
;; last is (listof Natural)
;; INVARIANT: previously generated part of the pattern, up to and not including
;;            the current depth; represents deeper parts of the BST
;;
;; Trivial case:   (= depth target)
;; Reduction step: (add1 depth)
;; Termination argument:
;;   For natural number target >= 0 and depth starting at 0,
;;   adding 1 to depth will cause it to eventually reach target
(define (depth->bst-pattern--acc target depth last)
  (if (= depth target)
      (cons-pattern depth last)
      (depth->bst-pattern--acc target (add1 depth) (cons-pattern depth last))))



(@htdf cons-pattern)
(@signature Natural (listof Natural) -> (listof Natural))
;; produce next pattern by prepending and appending list to given number
(check-expect (cons-pattern 0 empty) (list 0))
(check-expect (cons-pattern 4 (list 1 2 3)) (list 1 2 3 4 1 2 3))
(check-expect (cons-pattern 3 (list 0 1 0 2 0 1 0))
              (list 0 1 0 2 0 1 0 3 0 1 0 2 0 1 0))

;(define (cons-pattern n lon) empty) ;stub

(@template-origin Natural)

(@template
 (define (cons-pattern n lon)
   (... n lon)))

(define (cons-pattern n lon)
  (append lon (list n) lon))



(@htdf log2)
(@signature Number -> Number)
;; produce log base 2 of a number
;; CONSTRAINT: the given number must be positive
(check-expect (log2 0.5) -1)
(check-expect (log2 1) 0)
(check-expect (log2 16) 4)
(check-expect (log2 4294967296) 32)
(check-within (log2 10000) 13.28771237954945 APPROX)

;(define (log2 x) 0) ;stub

(@template-origin Number)

(@template
 (define (log2 x)
   (... x)))

(define (log2 x)
  (inexact->exact (/ (log x) (log 2))))


;;
;; TESTING FUNCTIONS
;;


(@htdf construct-bst-naive construct-bst-naive--acc)
(@signature (listof X) Natural -> BST)
;; construct binary search tree from given list (slow/non-TR implementation)
(check-expect (construct-bst empty 0) EMPTY-BST)
(check-expect (construct-bst (list 0) 1)
              (make-node 0 0 false false))
(check-expect (construct-bst (list 0 1 2 3 4) 5)
              (make-node 3 3
                         (make-node 1 1
                                    (make-node 0 0 false false)
                                    (make-node 2 2 false false))
                         (make-node 4 4 false false)))
(check-expect (construct-bst (list 0 1 2 3 4 5 6) 7)
              (make-node 3 3
                         (make-node 1 1
                                    (make-node 0 0 false false)
                                    (make-node 2 2 false false))
                         (make-node 5 5
                                    (make-node 4 4 false false)
                                    (make-node 6 6 false false))))

;(define (construct-bst-naive lst count) EMPTY-BST) ;stub

(@template-origin accumulator)

(define (construct-bst-naive lst count)
  (construct-bst-naive--acc lst 0))

(@template-origin genrec accumulator)

;; key is Natural
;; INVARIANT: the key of the first element of lst
(define (construct-bst-naive--acc lst key)
  (if (empty? lst)
      EMPTY-BST
      (make-node (+ key (sub1 (expt 2 (floor (log2 (length lst))))))
                 (list-ref lst (sub1 (expt 2 (floor (log2 (length lst))))))
                 (construct-bst-naive--acc
                  (take lst (sub1 (expt 2 (floor (log2 (length lst))))))
                  key)
                 (construct-bst-naive--acc
                  (drop lst (expt 2 (floor (log2 (length lst)))))
                  (+ key (expt 2 (floor (log2 (length lst)))))))))



(@htdf test-list)
(@signature Natural -> (listof Natural))
;; produce ascending list of nonnegative integers up to but not including n
(check-expect (test-list 0)  (list))
(check-expect (test-list 1)  (list 0))
(check-expect (test-list 10) (list 0 1 2 3 4 5 6 7 8 9))
(check-expect (test-list 16) (list 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15))

;(define (test-list n) empty) ;stub

(@template-origin accumulator)

(@template
 (define (test-list n)
   (test-list--acc (... n) (... n))))

(define (test-list n)
  (test-list--acc n empty))

(@template-origin Natural accumulator)

(@template
 (define (test-list--acc n rsf)
   (cond [(zero? n)
          (... rsf)]
         [else
          (... n rsf (test-list--acc (sub1 n) (... rsf)))])))

;; rsf is (listof Natural)
;; INVARIANT: all numbers between the current number and n, excluding n
(define (test-list--acc n rsf)
  (cond [(zero? n)
         rsf]
        [else
         (test-list--acc (sub1 n) (cons (sub1 n) rsf))]))



(@htdf test-bst-time-regular)
(@signature Natural -> Natural)
;; produce time to construct a BST with n elements
;; (tests not possible)

;(define (test-bst-time-regular n) 0) ;stub

(@template-origin Natural)

(@template
 (define (test-bst-time-regular n)
   (... n)))

(define (test-bst-time-regular n)
  (- (- (first (list (current-milliseconds)
                     (construct-bst (test-list n) n)))
        (current-milliseconds))))



(@htdf test-bst-time-naive)
(@signature Natural -> Natural)
;; produce time to construct a BST with n elements using naive implementation
;; (tests not possible)

;(define (test-bst-time-naive n) 0) ;stub

(@template-origin Natural)

(@template
 (define (test-bst-time-naive n)
   (... n)))

(define (test-bst-time-naive n)
  (- (- (first (list (current-milliseconds)
                     (construct-bst-naive (test-list n) n)))
        (current-milliseconds))))
